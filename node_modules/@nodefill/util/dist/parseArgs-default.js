"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const getMainArgs_js_1 = __importDefault(require("#lib/getMainArgs.js"));
const argsToTokens_js_1 = __importDefault(require("./lib/argsToTokens.js"));
function parseArgs(config = {}) {
    const { args = (0, getMainArgs_js_1.default)(), strict = true, tokens: returnTokens = false, options = Object.create(null), } = config;
    const { allowPositionals = !strict } = config;
    // 1. Parse the arguments into tokens
    const tokens = (0, argsToTokens_js_1.default)(args, options);
    // 2. Parse the tokens into values
    const result = {
        values: Object.create(null),
        positionals: [],
        ...(returnTokens && { tokens }),
    };
    for (const token of tokens) {
        if (token.kind === "option") {
            if (strict) {
                if (options[token.name] === undefined) {
                    throw new DOMException(`Unexpected option ${token.name}`, "SyntaxError");
                }
                if (options[token.name].type === "string" &&
                    typeof token.value !== "string") {
                    throw new DOMException(`Expected string value for ${token.name}`, "TypeError");
                }
                else if (options[token.name].type === "boolean" &&
                    token.value != null) {
                    throw new DOMException(`${token.name} does not take a value`, "TypeError");
                }
                if (!token.inlineValue && token.value?.startsWith("-")) {
                    throw new DOMException(`Unexpected option ${token.value}`, "SyntaxError");
                }
            }
            const actualValue = token.value ?? true;
            if (options[token.name]?.multiple) {
                if (result.values[token.name] === undefined) {
                    result.values[token.name] = [];
                }
                result.values[token.name].push(actualValue);
            }
            else {
                result.values[token.name] = actualValue;
            }
        }
        else if (token.kind === "positional") {
            if (!allowPositionals) {
                throw new DOMException(`Unexpected positional argument ${token.value}`, "SyntaxError");
            }
            result.positionals.push(token.value);
        }
    }
    // 3. Fill in defaults
    for (const [name, option] of Object.entries(options)) {
        if (option.default !== undefined && result.values[name] === undefined) {
            result.values[name] = option.default;
        }
    }
    return result;
}
module.exports = parseArgs;
